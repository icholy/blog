<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Golang on Choly&#39;s Blog</title>
    <link>http://choly.ca/tags/golang/</link>
    <description>Recent content in Golang on Choly&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 19 Mar 2016 15:41:44 -0400</lastBuildDate>
    <atom:link href="http://choly.ca/tags/golang/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>TypeScript: Working with JSON</title>
      <link>http://choly.ca/post/typescript-json/</link>
      <pubDate>Sat, 19 Mar 2016 15:41:44 -0400</pubDate>
      
      <guid>http://choly.ca/post/typescript-json/</guid>
      <description>&lt;p&gt;&lt;strong&gt;EDITS:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Calling &lt;code&gt;toString&lt;/code&gt; on &lt;code&gt;Date&lt;/code&gt; is for illustrative purposes.&lt;/li&gt;
&lt;li&gt;There&amp;rsquo;s a full commented example at the end.&lt;/li&gt;
&lt;li&gt;Use &lt;code&gt;toJSON&lt;/code&gt; method as suggested by &lt;a href=&#34;http://choly.ca/post/typescript-json/#comment-2579762437&#34;&gt;Schipperz&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Add &lt;code&gt;reviver&lt;/code&gt; method as suggested by &lt;a href=&#34;http://choly.ca/post/typescript-json/#comment-2579491209&#34;&gt;Anders Ringqvist&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;So you have a &lt;code&gt;User&lt;/code&gt; type in your code.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;interface User {
  name:    string;
  age:     number;
  created: Date;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At some point you&amp;rsquo;re going to want to encode this as JSON.
This works as you&amp;rsquo;d expect.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; &amp;gt; JSON.stringify({ name: &amp;quot;bob&amp;quot;, age: 34, created: new Date() });
&#39;{&amp;quot;name&amp;quot;:&amp;quot;bob&amp;quot;,&amp;quot;age&amp;quot;:34,&amp;quot;created&amp;quot;:&amp;quot;2016-03-19T18:15:12.710Z&amp;quot;}&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The problem is that the &lt;code&gt;created&lt;/code&gt; field is no longer a &lt;code&gt;Date&lt;/code&gt; when you parse it back.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; JSON.parse(&#39;{&amp;quot;name&amp;quot;:&amp;quot;bob&amp;quot;,&amp;quot;age&amp;quot;:34,&amp;quot;created&amp;quot;:&amp;quot;2016-03-19T18:15:12.710Z&amp;quot;}&#39;)
{ name: &#39;bob&#39;, age: 34, created: &#39;2016-03-19T18:15:12.710Z&#39; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The way I went about fixing this is by introducing a &lt;code&gt;UserJSON&lt;/code&gt; interface.&lt;br /&gt;
Since it only contains primitives, it can be converter to and from JSON without altering it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;interface UserJSON {
  name:    string;
  age:     number;
  created: string;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then I convert from &lt;code&gt;User&lt;/code&gt; -&amp;gt; &lt;code&gt;UserJSON&lt;/code&gt; before &amp;lsquo;stringifying&amp;rsquo; to JSON
and convert from &lt;code&gt;UserJSON&lt;/code&gt; -&amp;gt; &lt;code&gt;User&lt;/code&gt; after parsing from JSON.
Here&amp;rsquo;s an example of some client code doing this.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;function getUsers(): Promise&amp;lt;User[]&amp;gt; {
  return ajax.get&amp;lt;UserJSON[]&amp;gt;(&#39;/users&#39;).then(data =&amp;gt; {
    return data.data.map(decodeUser);
  });
}

function updateUser(id: number|string, user: User): Promise&amp;lt;{}&amp;gt; {
  return ajax.put&amp;lt;{}&amp;gt;(`/users/${id}`, encodeUser(user));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here are the conversion functions.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;function encodeUser(user: User): UserJSON {
  return {
    name:    user.name,
    age:     user.age,
    created: user.created.toString()
  };
}

function decodeUser(json: UserJSON): User {
  return {
    name:    json.name,
    age:     json.age,
    created: new Date(json.created)
  };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This works, but it&amp;rsquo;s a contrived example.
In real cases, there will be a lot more properties and this quickly turns into a huge pain in the ass.
Let&amp;rsquo;s use &lt;code&gt;Object.assign&lt;/code&gt; to clean it up a bit.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;function encodeUser(user: User): UserJSON {
  return Object.assign({}, user, {
    created: user.created.toString()
  });
}

function decodeUser(json: UserJSON): User {
  return Object.assign({}, json, {
    created: new Date(json.created)
  });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So far so good, but what happens when &lt;code&gt;User&lt;/code&gt; is a class?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;class User {

  private created: Date;

  constructor(
    private name: string,
    private age:  string
  ) {
    this.created = new Date();
  }

  getName(): string {
    return this.name;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For this to work, I use &lt;code&gt;Object.create&lt;/code&gt; to make a new instance of &lt;code&gt;User&lt;/code&gt; without using the constructor.
 Then assign the properties to that. The encoding function doesn&amp;rsquo;t change.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;function decodeUser(json: UserJSON): User {
  let user = Object.create(User.prototype);
  return Object.assign(user, json, {
    created: new Date(json.created)
  });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, the &lt;code&gt;encode&lt;/code&gt; and &lt;code&gt;decode&lt;/code&gt; functions can just be methods on the &lt;code&gt;User&lt;/code&gt; class.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;class User {

  private created: Date;

  constructor(
    private name: string,
    private age:  string
  ) {
    this.created = new Date();
  }

  getName(): string {
    return this.name;
  }

  encode(): UserJSON {
    return Object.assign({}, this, {
      created: this.created.toString()
    });
  }

  static decode(json: UserJSON): User {
    let user = Object.create(User.prototype);
    return Object.assign(user, json, {
      created: new Date(json.created)
    });
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When &lt;code&gt;JSON.stringify&lt;/code&gt; is invoked on an object, it checks for a method called &lt;code&gt;toJSON&lt;/code&gt;
to convert the data before &amp;lsquo;stringifying&amp;rsquo; it. In light of this, let&amp;rsquo;s rename &lt;code&gt;encode&lt;/code&gt; and
&lt;code&gt;decode&lt;/code&gt; to &lt;code&gt;toJSON&lt;/code&gt; and &lt;code&gt;fromJSON&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;class User {

  /* ... */

  toJSON(): UserJSON {
    return Object.assign({}, this, {
      created: this.created.toString()
    });
  }

  static fromJSON(json: UserJSON): User {
    let user = Object.create(User.prototype);
    return Object.assign(user, json, {
      created: new Date(json.created)
    });
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We don&amp;rsquo;t need to call &lt;code&gt;user.encode()&lt;/code&gt; explicitly anymore!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;let data = JSON.stringify(new User(&amp;quot;Steve&amp;quot;, 39));
let user = User.fromJSON(JSON.parse(data));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is good, but we can do better. &lt;code&gt;JSON.parse&lt;/code&gt; accepts a second parameter called
&lt;code&gt;reviver&lt;/code&gt; which is a function that gets called with every key/value pair in the object
as it&amp;rsquo;s being parsed. The root object is passed to &lt;code&gt;reviver&lt;/code&gt; with an empty string as the key.
Let&amp;rsquo;s add a &lt;code&gt;reviver&lt;/code&gt; function to our &lt;code&gt;User&lt;/code&gt; class.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;class User {

  /* ... */

  static reviver(key: string, value: any): any {
    return key === &amp;quot;&amp;quot; ? User.fromJSON(value) : value;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can write:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;let user = JSON.parse(data, User.reviver);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Not too shabby&amp;hellip;&lt;/p&gt;

&lt;p&gt;The nice thing about using this pattern is that it composes very well.&lt;br /&gt;
Say the user had an &lt;code&gt;account&lt;/code&gt; property which contained an instance of &lt;code&gt;Account&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;class User {

  private account: Account;

  /* ... */
  
  static fromJSON(json: UserJSON): User {
    let user = Object.create(User.prototype);
    return Object.assign(user, json, {
      created: new Date(json.created),
      account: Account.fromJSON(json.account)
    });
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And here&amp;rsquo;s the full commented &lt;code&gt;User&lt;/code&gt; class.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;class User {

  private created: Date;

  constructor(
    private name: string,
    private age:  string
  ) {
    this.created = new Date();
  }

  getName(): string {
    return this.name;
  }

  // toJSON is automatically used by JSON.stringify
  toJSON(): UserJSON {
    // copy all fields from `this` to an empty object and return in
    return Object.assign({}, this, {
      // convert fields that need converting
      created: this.created.toString()
    });
  }

  // fromJSON is used to convert an serialized version
  // of the User to an instance of the class
  static fromJSON(json: UserJSON|string): User {
    if (typeof json === &#39;string&#39;) {
      // if it&#39;s a string, parse it first
      return JSON.parse(json, User.reviver);
    } else {
      // create an instance of the User class
      let user = Object.create(User.prototype);
      // copy all the fields from the json object
      return Object.assign(user, json, {
        // convert fields that need converting
        created: new Date(json.created),
      });
    }
  }

  // reviver can be passed as the second parameter to JSON.parse
  // to automatically call User.fromJSON on the resulting value.
  static reviver(key: string, value: any): any {
    return key === &amp;quot;&amp;quot; ? User.fromJSON(value) : value;
  }
}

// A representation of User&#39;s data that can be converted to
// and from JSON without being altered.
interface UserJSON {
  name:    string;
  age:     number;
  created: string;
}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Custom JSON Marshalling in Go</title>
      <link>http://choly.ca/post/go-json-marshalling/</link>
      <pubDate>Fri, 10 Apr 2015 12:54:44 -0400</pubDate>
      
      <guid>http://choly.ca/post/go-json-marshalling/</guid>
      <description>&lt;p&gt;Go&amp;rsquo;s &lt;code&gt;encoding/json&lt;/code&gt; package makes it really easy to marshal &lt;code&gt;struct&lt;/code&gt;s to JSON data.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;encoding/json&amp;quot;
	&amp;quot;os&amp;quot;
	&amp;quot;time&amp;quot;
)

type MyUser struct {
	ID       int64     `json:&amp;quot;id&amp;quot;`
	Name     string    `json:&amp;quot;name&amp;quot;`
	LastSeen time.Time `json:&amp;quot;lastSeen&amp;quot;`
}

func main() {
	_ = json.NewEncoder(os.Stdout).Encode(
		&amp;amp;MyUser{1, &amp;quot;Ken&amp;quot;, time.Now()},
	)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Output:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&amp;quot;id&amp;quot;:1,&amp;quot;name&amp;quot;:&amp;quot;Ken&amp;quot;,&amp;quot;lastSeen&amp;quot;:&amp;quot;2009-11-10T23:00:00Z&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But what if we want to change how one of the field values are displayed? For example, say I wanted &lt;code&gt;LastSeen&lt;/code&gt; to be a unix timestamp.&lt;/p&gt;

&lt;p&gt;The simple solution is to introduce another auxiliary &lt;code&gt;struct&lt;/code&gt; and populate it with the correctly formatted values in the &lt;code&gt;MarshalJSON&lt;/code&gt; method.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (u *MyUser) MarshalJSON() ([]byte, error) {
	return json.Marshal(&amp;amp;struct {
		ID       int64  `json:&amp;quot;id&amp;quot;`
		Name     string `json:&amp;quot;name&amp;quot;`
		LastSeen int64  `json:&amp;quot;lastSeen&amp;quot;`
	}{
		ID:       u.ID,
		Name:     u.Name,
		LastSeen: u.LastSeen.Unix(),
	})
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This works, but it can get cumbersome when there are lots of fields.
It would be nice if we could embed the original &lt;code&gt;struct&lt;/code&gt; into the auxiliary &lt;code&gt;struct&lt;/code&gt; and have it inherit all the fields that do not need to be changed.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (u *MyUser) MarshalJSON() ([]byte, error) {
	return json.Marshal(&amp;amp;struct {
		LastSeen int64 `json:&amp;quot;lastSeen&amp;quot;`
		*MyUser
	}{
		LastSeen: u.LastSeen.Unix(),
		MyUser:   u,
	})
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The problem here is that the auxiliary &lt;code&gt;struct&lt;/code&gt; will also inherit the original&amp;rsquo;s &lt;code&gt;MarshalJSON&lt;/code&gt; method, causing it to go into an infinite loop. The solution is to alias the original type. This alias will have all the same fields, but none of the methods.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (u *MyUser) MarshalJSON() ([]byte, error) {
	type Alias MyUser
	return json.Marshal(&amp;amp;struct {
		LastSeen int64 `json:&amp;quot;lastSeen&amp;quot;`
		*Alias
	}{
		LastSeen: u.LastSeen.Unix(),
		Alias:    (*Alias)(u),
	})
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The same technique can be used for implementing an &lt;code&gt;UnmarshalJSON&lt;/code&gt; method.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (u *MyUser) UnmarshalJSON(data []byte) error {
	type Alias MyUser
	aux := &amp;amp;struct {
		LastSeen int64 `json:&amp;quot;lastSeen&amp;quot;`
		*Alias
	}{
		Alias: (*Alias)(u),
	}
	if err := json.Unmarshal(data, &amp;amp;aux); err != nil {
		return err
	}
	u.LastSeen = time.Unix(aux.LastSeen, 0)
	return nil
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>